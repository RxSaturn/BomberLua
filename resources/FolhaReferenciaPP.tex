\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{mathptmx} 
\usepackage{setspace}
\usepackage{ragged2e}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{abntex2cite} 


\begin{document}
	
	\thispagestyle{empty}
	
	\begin{center}
		\textbf{IFMG - \textit{CAMPUS BAMBUÍ}}\\
		BACHARELADO EM ENGENHARIA DE COMPUTAÇÃO
	\end{center}
	
	\vspace{6cm}
	
	\begin{center}
		\textbf{RAYSSA MENDES DA SILVA}
	\end{center}
	
	\vspace{4cm}
	
	\begin{center}
		\textbf{Trabalho Final: Folha de referência Lua.}\\
		Paradigmas de programação
	\end{center}
	
	\vfill
	
	\begin{center}
		Bambuí - MG\\
		2024
	\end{center}
	
	\newpage
	
	\section{TIPOS DE DADOS}
	A linguagem Lua possui um conjunto reduzido e eficiente de tipos de dados primitivos e compostos. Além disso possui uma tipagem dinâmica, ou seja, o tipo está diretamente nos dados e não nas referências. Nesta seção, serão apresentados os 8 principais tipos de dados disponíveis, com descrição e exemplos de códigos. \citeonline{lplua}
	
	
	\subparagraph{1.1 TIPOS PRIMITIVOS}
	\begin{itemize}
		\item \textbf{number}: Tipo numérico. Representa inteiros e números de ponto flutuante. Lua não distingue entre os dois, todos são tratados como \textbf{number}.
		
		\textbf{Exemplo:}
		\begin{verbatim}
			x = 10
			y = 3.14
		\end{verbatim}
		
		\item \textbf{boolean}: Representa valores lógicos \texttt{true} (verdadeiro) e \texttt{false} (falso). Qualquer valor diferente de \texttt{false} e \texttt{nil} é considerado verdadeiro.
		
		\textbf{Exemplo:}
		\begin{verbatim}
			ativo = true
			desativado = false
		\end{verbatim}
		
		\item \textbf{string}: Representa cadeias de caracteres (texto). Pode ser delimitada por aspas simples, duplas ou colchetes de nível longo.
		
		\textbf{Exemplo:}
		\begin{verbatim}
			nome = "Rayssa"
			mensagem = 'Salve, Ciniro!'
		\end{verbatim}
		
		\item \textbf{nil}: Representa ausência de valor ou variável não inicializada.
		
		\textbf{Exemplo:}
		\begin{verbatim}
			x = nil
		\end{verbatim}
	\end{itemize}
	
	\subsection*{1.2 Enumerações}
	
	Lua não possui suporte direto a enumerações como em outras linguagens, mas é possível simular esse comportamento usando tabelas com chaves constantes.
	
	\textbf{Exemplo:}
	\begin{verbatim}
		Cores = { VERMELHO = 1, VERDE = 2, AZUL = 3 }
		print(Cores.VERDE)
		Saída: 2
	\end{verbatim}
	
	\subsection*{1.3 Tipos Compostos}
	
	\begin{itemize}
		\item \textbf{tabela (table)}: Tipo de dado mais versátil da linguagem. Pode ser usado como vetor, matriz, dicionário, lista, entre outros. As tabelas são estruturas associativas.
		
		\textbf{Exemplos:}
		\begin{verbatim}
			vetor = {1, 2, 3}
			dicionario = {nome = "Luan", idade = 28}
			matriz = {
				{1, 2},
				{3, 4}
			}
		\end{verbatim}
		
		\item \textbf{função (function)}: Em Lua, funções também são valores e podem ser armazenadas em variáveis, passadas como argumentos, etc.
		
		\begin{verbatim}
			function saudacao()
			print("Olá!")
			end
		\end{verbatim}
	\end{itemize}
	
	\subsection*{1.4 Tipos Especiais}
	
	\begin{itemize}
		\item \textbf{userdata}: Variáveis do tipo userdata só pode ser utilizada em programas LUA-C, pois não podem ser criadas em programas feito somente em LUA.
		
		\item \textbf{thread}: Permite execução cooperativa de múltiplos blocos de código. O tipo threads não são os processos do sistema operacional, mas sim usado para implementar co-rotinas.
		
		\begin{verbatim}
			co = coroutine.create(function ()
			print("Execução em coroutine")
			end)
		\end{verbatim}
	\end{itemize}
	\section{OPERANDOS E OPERADORES}
	Nesta seção, apresentamos as regras de precedência, associatividade, ordem de avaliação e efeitos colaterais relacionados a operandos e operadores na linguagem Lua, com exemplos práticos.
	
	\subsection*{2.1 Regras de Precedência dos Operadores}
	
	Lua possui uma ordem de precedência bem definida entre seus operadores. Abaixo, estão listados do mais forte (avaliado primeiro) para o mais fraco:
		\begin{enumerate}
			\item \verb|^| (exponenciação)
			\item \verb|not|, \verb|#|, \verb|-| (operadores unários: negação lógica, comprimento, negação numérica)
			\item \verb|*|, \verb|/|, \verb|//|, \verb|%| (multiplicação, divisão, divisão inteira, módulo)
			\item \verb|+|, \verb|-| (soma e subtração binária)
			\item \verb|..| (concatenação de strings)
			\item \verb|<|, \verb|<=|, \verb|>|, \verb|>=|, \verb|~=|, \verb|==| (comparações)
			\item \verb|and| (conjunção lógica)
			\item \verb|or| (disjunção lógica)
		\end{enumerate}
	\textbf{Exemplo:}
	\begin{verbatim}
		print(2 + 3 * 4)  
		Resultado: 14 (multiplicação antes da soma)
		 
		print("oi" .. "Lua") 
		Resultado: oiLua (concatenação)
		  
		print(not false or true) 
		Resultado: true (not tem maior precedência que or)
	\end{verbatim}
	
		\subsection*{2.2  Regras de Associatividade de Operadores}
		A associatividade define a direção em que operadores com a mesma precedência são avaliados:
		\begin{itemize}
		\item A maioria dos operadores binários é \textbf{associativa à esquerda}, como \verb|+|, \verb|-|, \verb|*|, etc.
		\item O operador \verb|^| (exponenciação) e o operador de concatenação \verb|..| são \textbf{associativos à direita}.
		\end{itemize}
		
		\textbf{Exemplo:}
		\begin{verbatim}
			print(2 ^ 3 ^ 2) 
			Resultado: 512, pois é avaliado como 2 ^ (3 ^ 2)
			
			print("a" .. "b" .. "c")
			Resultado: abc
		\end{verbatim}
		
		\subsection*{2.3 Ordem de Avaliação dos Operandos}
		
		Em Lua, a ordem de avaliação dos operandos é sempre da \textbf{esquerda para a direita}.
		
		\textbf{Exemplo:}
		\begin{verbatim}
			function f() 
			print("f")
			return 1
			end
			
			
			function g()
			print("g")
			return 2
			end
			
			print(f() + g()) 
			Saída: f g 3
		\end{verbatim}
		
		\textbf{Explicação:} A função 'f()' é chamada antes de 'g()'.
		
			\subsection*{2.4 Existem restrições acerca de efeitos colaterais na avaliação dos operandos?}
			Lua permite efeitos colaterais, mas é importante ter cuidado ao usar múltiplas chamadas com efeitos na mesma expressão. O uso incorreto pode levar a resultados inesperados.
			
			\textbf{Exemplo incorreto:}
			\begin{verbatim}
				a = {1, 2, 3}
				i = 1
				print(a[i] + i, i)
				i = i + 1
			\end{verbatim}
			
			\textbf{Boa prática:} Evitar múltiplas modificações da mesma variável dentro de uma única expressão.
			
			Lua avalia expressões da esquerda para a direita, mas os efeitos colaterais (como incremento de variáveis) podem interferir se não forem bem controlados.
			
				
				\subsection*{2.5 A linguagem permite a sobrecarga de operadores?}
				
				
				Lua utiliza metatables para alterar o comportamento das tabelas, permitindo sobrecarga de operadores. \cite{codeporting}
				
				\textbf{Exemplo:}
				\begin{verbatim}
				mt = {}
				mt.__add = function(t1, t2)
				return t1[1] + t2[1]
				end
				
				setmetatable(t1, mt)
				setmetatable(t2, mt)
				print(t1 + t2)  
				Saída: Resultado baseado na implementação
			\end{verbatim}
			\newpage
			
			\section{CONVERSÃO E ESTRUTURA DE ATRIBUIÇÃO}
			Nesta seção, explicamos como a linguagem Lua trata conversões de tipos (implícitas e explícitas), além das formas de atribuição suportadas.
			
			\subsection*{3.1 Como funciona a conversão de tipos implícita e explícita?}
			
			Lua possui tipagem dinâmica e fraca. Isso significa que o tipo das variáveis é determinado em tempo de execução e, em alguns casos, pode ser convertido automaticamente. As conversões podem ser:
			
			\subsubsection{Conversão Implícita}
			
			
			Lua realiza conversão implícita apenas em contextos específicos, como a concatenação de strings com números.
			
			\textbf{Exemplo:}
			\begin{verbatim}
				print("A resposta é: " .. 42) 
				Resultado: A resposta é: 42
			\end{verbatim}
			
			Contudo, Lua \textbf{não} converte automaticamente strings em números em expressões aritméticas:
			
			\begin{verbatim}
				print("10" + 1)
				ERRO: tentativa de realizar operação aritmética em string
			\end{verbatim}
			
			
			\subsubsection*{3.0.2 Conversão Explícita}
			
			Para conversões seguras, é necessário utilizar funções de conversão como:
			
			\begin{itemize}
				\item \verb|tonumber(s)| – tenta converter uma string para número. Retorna \verb|nil| se falhar.
				\item \verb|tostring(v)| – converte qualquer valor para uma string.
			\end{itemize}
			
			\textbf{Exemplos:}
			\begin{verbatim}
				num = tonumber("123")
				str = tostring(3.14)
				
				print(type(num))   number
				print(type(str))   string
			\end{verbatim}
			
			\subsection*{3.2 Como é feita e quais estruturas de atribuição são permitidas?}
			
			Lua permite diferentes formas de atribuição. Todas as variáveis são criadas dinamicamente e não precisam de declaração prévia.
			
			\subsubsection*{Atribuição Simples}
			
			É a forma mais comum, associando um valor a uma variável:
			
			\begin{verbatim}
				x = 10
				mensagem = "Olá"
				ativo = true
			\end{verbatim}
			
			\subsubsection*{Atribuição Múltipla}
			
			Permite atribuir múltiplos valores a múltiplas variáveis ao mesmo tempo:
			
			\begin{verbatim}
				a, b, c = 1, 2, 3
				print(a, b, c)
				Resultado: 1  2  3
			\end{verbatim}
			
			Se houver menos valores que variáveis, as variáveis extras recebem \verb|nil|:
			
			\begin{verbatim}
				x, y, z = 1, 2
				print(z) 
				Resultado: nil
			\end{verbatim}
			
			\subsubsection*{Troca de valores}
			
			A atribuição múltipla permite a troca direta de valores entre variáveis:
			
			\begin{verbatim}
				x, y = 5, 10
				x, y = y, x
				print(x, y) 
				Resultado: 10  5
			\end{verbatim}
			\newpage
			
			\section{SENTENÇAS DE SELEÇÃO}
			
			Nessa seção, apresentamos as sentenças de seleção, Lua fornece um conjunto pequeno e convencional de estruturas de controle, com \verb|if| e \verb|while| para condicional, \verb|repeat| e \verb|for| para iteração. Todas as estruturas de controle têm um terminador explícito: \verb|end| encerra as estruturas \verb|if| , \verb|for| e \verb|while| ; e \verb|until| encerra a estrutura \verb|repeat|.
			
			A expressão condicional de uma estrutura de controle pode resultar em qualquer valor. Lua trata como verdadeiros todos os valores diferentes de falso e nulo. \citeonline{pil}
			
			\subsection*{4.1 A linguagem permite sentenças de seleção?}
			
			Sim, a linguagem Lua permite o uso de sentenças de seleção para controlar o fluxo condicional de execução de blocos de código.
			
			\subsection*{4.2 Quais sentenças são permitidas e como funcionam?}
			
			\subsubsection*{4.2.1 Sentenças de dois caminhos (if-then-else)}
			
			A estrutura básica de decisão em Lua utiliza o comando \verb|if|, com suporte para os blocos \verb|then| e \verb|else|.
			
			\textbf{Exemplo:}
			\begin{verbatim}
				idade = 18
				if idade >= 18 then
				print("Maior de idade")
				else
				print("Menor de idade")
				end
				
				Saída: Maior de idade
			\end{verbatim}
			
			\subsubsection*{4.2.2 Múltiplas decisões com else-if}
			
			Lua permite o uso de \verb|elseif| para testar várias condições sequencialmente.
			
			\textbf{Exemplo:}
			\begin{verbatim}
				nota = 7.5
				if nota >= 9 then
				print("Excelente")
				elseif nota >= 7 then
				print("Bom")
				elseif nota >= 5 then
				print("Regular")
				else
				print("Reprovado")
				end
			\end{verbatim}
			
			\subsubsection*{4.2.3 Estrutura semelhante ao switch-case}
			
			Lua \textbf{não possui} uma estrutura nativa \texttt{switch-case-default}, como em outras linguagens (ex: C, Java). Porém, esse comportamento pode ser simulado utilizando tabelas (tables) e funções anônimas.
			
			\textbf{Exemplo simulando switch-case:}
			\begin{verbatim}
				opcao = "b"
				
				acoes = {
					a = function() print("Você escolheu A") end,
					b = function() print("Você escolheu B") end,
					c = function() print("Você escolheu C") end
				}
				
				if acoes[opcao] then
				acoes[opcao]()
				else
				print("Opção inválida")
				end
			\end{verbatim}
			
			\subsection*{4.3 Como fluxos diferentes são explorados se não houver estrutura nativa?}
			
			Como Lua não possui \verb|switch-case|, o programador pode usar \verb|if-elseif-else| ou tabelas com funções, como mostrado anteriormente, para simular múltiplos caminhos. Essa abordagem é flexível e permite inclusive armazenar lógicas completas dentro das tabelas.
			
			
			Com isso, demonstramos que Lua possui controle de fluxo condicional baseado em \texttt{if} e pode simular estruturas mais complexas de seleção.
			\newpage
			
			\section{SETENÇAS DE ITERAÇÃO}
			
			Lua permite diversas formas de sentenças de repetição (iterações), oferecendo estruturas como \verb|while|, \verb|repeat-until| e \verb|for|. A linguagem é simples, mas poderosa, permitindo iterar tanto com controle por contador quanto por condição lógica ou sobre estruturas de dados (como tabelas). \citeonline{pil}
			
			\subsection*{5.1 A linguagem permite sentenças de iteração?}
			
			Sim, Lua permite o uso de laços de repetição com três formas principais:
			
			\begin{itemize}
				\item \verb|while ... do ... end|
				\item \verb|repeat ... until|
				\item \verb|for ... do ... end| (numérico e genérico)
			\end{itemize}
			
			\subsection*{5.2 Como funcionam as controladas por contador (\texttt{for})?}
			
			Lua possui um laço \verb|for| numérico que executa um bloco de código por um número determinado de vezes, controlado por um contador com valor inicial, final e opcionalmente um passo.
			
			\textbf{Exemplo:}
			\begin{verbatim}
				for i = 1, 5 do
				print(i)
				end
				
				Com passo:
				for i = 10, 1, -2 do
				print(i)
				end
			\end{verbatim}
			
			\subsection*{5.3 Como funcionam as controladas logicamente (\texttt{while})?}
			
			O laço \verb|while| avalia uma condição lógica antes de cada iteração. O bloco será executado enquanto a condição for verdadeira.
			
			\textbf{Exemplo:}
			\begin{verbatim}
				contador = 1
				while contador <= 5 do
				print(contador)
				contador = contador + 1
				end
			\end{verbatim}
			
			\subsection*{5.4 Como funcionam as controladas por estrutura de dados (foreach)?}
			
			Lua não possui um comando \verb|foreach| específico como em outras linguagens, mas o comportamento equivalente pode ser feito com o laço \verb|for ... in| (também chamado de \textbf{for genérico}), usado para iterar sobre tabelas, arrays, strings e outros iteradores.
			
			\textbf{Exemplo:}
			\begin{verbatim}
				nomes = {"Ana", "Bruno", "Carlos"}
				
				for i, nome in ipairs(nomes) do
				print(i, nome)
				end
			\end{verbatim}
			
			Neste exemplo, \verb|ipairs| é uma função que retorna um iterador para percorrer elementos sequenciais de uma tabela. Há também a função \verb|pairs| para iterar sobre todos os pares chave-valor (mesmo que não sejam sequenciais).
			
			
			Com isso, Lua demonstra ser capaz de trabalhar com diferentes formas de iteração, permitindo controle tanto numérico quanto lógico e estrutural.
			\newpage
			\bibliographystyle{abntex2-alf}
			\bibliography{referenciasPP}
			
\end{document}
